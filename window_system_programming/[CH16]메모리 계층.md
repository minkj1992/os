
# [CH16] 메모리

## 메모리 공간 계층
- 메모리를 계층적으로 나누어 놓은 이유
	1. 용도를 나누기 위하여
		- HDD는 저렴하고 정보를 유지할 수 있다. 그렇기에 주로 실행 파일(프로그램)을 저장한다.
		- 메인메모리(RAM)은 빠르고 비싸다 + 휘발성. 그렇기에 HDD 프로그램 실행전 준비 단계를 담당
		- 레지스터는 CPU연산담당
	2. 속도의 완충역할
		- 각 계층별로 속도차이가 엄청난데 CPU와 HDD만 있었다면 HDD에서 I/O작업을 하느라 거의 모든 시간을 사용하고, CPU는 I/O작업이 일어날 때마다 무한정 대기를 하고 있었을 것이다. 이로 인해 매
우 비효율적인 자원 관리가 일어난다.

## 지역성(`Locality`)
> 캐시의 서막

프로그램은 실행하고 있는 곳 주변을 실행하는 경향이 있다. 그러다가 다른 번지로 jump하고 또 그 주변을 실행한다. 이렇듯 프로그램은 지역적인 곳을 탐색하는 특징이 있다.

- Locality의 특징
	- 반복 접근성(Temporal Locality)
		- 한번 선언한 변수는 이후 다시 접근할 확률이 높다.
	- 주변 접근성(Spatial Locality)
		- 사용하고 있는 변수 근처에 위치한 변수를 접근할 확률이 높다.

## 캐시(`Cache`)
캐시에 대해서 설명하자면, 캐시는 다른 메모리와 비슷한 기능을 갖지만 속도가 빠르고 비싸다는 특징이 있다. 캐시를 메인메모리로 쓰기에는 가격적 부담이 크다는 이야기다. 그래서 캐시를 CPU와 RAM 사이에 두고 BottleNeck현상을 줄여주는 하나의 버퍼로 사용한 것이다. 

캐시는 연산이 빠르므로 RAM에서 현재 실행중인 `블럭`(블럭일까 페이지일까?)을 캐시에 올린 뒤, CPU에서 캐시를 통해 연산하도록 하였다.

- 데이터를 탐색 순서 
	1. ALU가 캐시에게 데이터 요청
	2. 없다면 L2 캐시에게 요청
	3. 없다면 RAM에게 요청
	4. 없다면 HDD에게 요청
	5. 이후 역순으로 ALU에게 전달
만약 프로그램이 산발적이라면 이런 계층구조는 부담스러울 것이다. 하지만 프로그램은 Locality성격을 띄고 있으며, 현재 실행하고 있는 프로그램 주변부를 상위 메모리에 Cache 시켜두면, 아래로 깊게 내려오며 탐색할 확률은 기하급수적으로 줄어든다.

여담으로 캐시를 사용하면 캐시 힛ratio가 90%이상이라고 한다. (반대말을 cache miss)

- 캐시의 특성별 구현
	- 메모리 계층 사이사이에 위계질서에 맞춰서 데이터들을 저장하는 이유는 `Temporal Locality`가 발현
	-  블록단위로 각 메모리 계층에 하위 계층 데이터들이 상위 계층 단위에 올라가는 이유는 `Spacial Locality`가 발현되서이다.

## 가상 메모리
> Virtual Memory = RAM + HDD

메모리 계층상, 상위 계층 메모리는 하위 계층에 비해 용량이 적다. 이런 물리적인 한계를 극복하기 위해서 가상메모리를 도입하여 **"OS는 마치 RAM의 크기가 RAM + HDD라고 느끼도록 만듬"**

여기서 눈여겨 봐야할 점은 하나의 프로그램이 일부분은 RAM에 존재하고 일부분은 HDD에 존재하면 프로그램을 실행 할 경우 램에 접근하면 빠르다가 HDD로 접근할때 갑자기 느려지는 현상이 있을까?이다. 실제로는 절대 그렇지 않고 이를 해결해 준 것이 `가상 메모리 기법`이다.

### 개념
RAM에는 실행에 필요한 최소한의 페이지들만 올려두어 프로세스를 돌리고, 나머지 용량을 초과하는 부분들은 HDD에 넣어두고 적절할 때(`Page Fault`) RAM에 들어있는 필요없는 요소와 바꿔주는 것이다. (`Page Swap`)  

### 가상 주소와 물리주소 
- `가상 주소`: 가상 메모리를 구현하기 위해, HDD내의 공간을 가상 메모리로 표현하여 할당한 주소
- 우리가 만든 프로그램은 OS에게 실제 메모리 할당에 관련한 일들을 위임한다.
- 운영체제는 메모리 요청을 처리하는 `MMU`(Memory Management Unit)에서 요청을 처리하고 메모리 관련 작업을 수행한다.
- `가상 메모리`는 물리 메모리 주소를 `블록`단위로 저장한다
- 물리 메모리 관점에서 이 블럭을 `page Frame`이라고 한다. (그런데 HDD에서 RAM으로 참조할때는 WORD단위로 가져오지 않나? )

### 프로세스와 가상 메모리
모든 프로세스는 자신만의 가상 주소 공간을 가지고 있다. 32비트/64비트 프로세스는 각 비트수에 맞게 최대 4GB/16GB의 주소 공간을 가진다. 모든 프로세스들은 자신만의 주소 공간을 가지기 때문에 특정 프로세스 내에서 쓰레드가 수행될 때 해당 쓰레드는 프로세스가 소유하고 있는 메모리에 대해서만 접근이 가능하다.

ㅍ로세스는 실제 필요로 하는 부분만 메모리로 올리는 `Demand-Paging`기법을 사용한다. HDD 상에 존재하는 파일(VM에 할당된)을 `Swap file`(`Paging file`)리라고 하며, 모든 프로세스가 사용할 수 있는 가상 메모리로 사용된다.

### Demanding Page
- `valid bit`: 페이지 테이블에 해당 page가 물리 메모리에 있으면 `set`/ 없으면 `invalid`값 넣어준다.
- `valid bit`가 clear되어 있는 상태 (= Page가 Physical Memory에 없는 상태)를 가리켜 `Page fault`라고 한다.
- `page fault` 처리 과정
	1. 페이지 테이블에서 valid bit값이 `invalid` 확인
	2. OS에게 trap(interrupt)
	3. OS는 정말로 메모리에 없는지 / 접근이 잘못된 것인지 확인
	4. Empty Frame(free page)를 ram에서 가져온다.
		- 만약 Empty Frame이 없는 경우 (RAM), Page Replacement Algorithm(`LRU`) 가동
	5. Page를 frame으로 swap
	6. `page-table`과 `TLB`를 update
	7. `page fault` 지점부터 다시 수행
