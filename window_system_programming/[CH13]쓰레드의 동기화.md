# [CH13] 동기화

## 쓰레드 동기화란 무엇인가?

- 쓰레드 동기화 기법의 두 가지 구분
	- 유저 모드 동기화
		- 크리티컬 섹션 기반 동기화
		- 인터락 함수 기반 동기화
			- 동기화 해주어야 하는 영역이 작을 때, 손쉽게 구현가능
	- 커널 모드 동기화
- 접근 동기화
- 뮤텍스 기반 동기화
- 세마포어 기반 동기화
- 이름있는 뮤텍스 기반 동기화
- 이벤트 기반 동기화
- 실행순서 동기화
- 이벤트 기반 동기화

## 임계영역 접근 동기화

- 크리티컬 섹션 기반의 동기화
-
```c  
CRITICAL_SECTION gCriticalSection //cirical section object

InitializeCriticalSection(&gCriticalSection); // init obj (key 생성등)

EntereCriticalSection(&CritticalSection); //임계영역 진입을 위해 크리티컬 섹션오브젝트(뮤텍스, 세마포어 등?) 획득

// 임계영역 활동  
  
LeaveCriticalSection(&CriticalSection); //key 반환

...  
DeleteCriticalSection(&CriticalSection); // key 삭제  
```  

- 갑자기 궁금한 것은 트랜잭션과 임계영역 관계
- `InterlockedIncrement`: 인터락 함수 기반의 동기
- `timeInterrupt Disable`: os레벨의클럭을 time으로 추상화시켜서  사용함.
df
## 커널 모드 동기화
- 키의 갯수
	- 세마포어 (1이상)
	- 뮤텍스 (1)
	- 세마포어는 뮤텍스를 포함한다. 윈도우 구현상에서
- 뮤텍스 기반의 동기화
	- 뮤텍스(Kernel Object) 생성 -> 키요청-> `WaitForSingleObject()` -> 키 획득 -> 쓰레드가 `critical area`에 진입 -> 임계영역 종료 -> `ReleaseMutex(),(키(커널 오브젝트)를 signald(프로세스종료 되었음.)됙게  해주는 함수)`를 통해 뮤텍스  반납

- 세마포어의 생성
	- 세마포어 카운트가 0이 되지 않는다면, `WaitForSingleObject()`를 호출하더라도 `blocking`되지 않는다.
	- 즉 세마포어 카운트가 값을 가지고 있는 순간에는 언제나 `signald` 상태로 세마포어가 진행된다. 

## 커널 모드 동기화(2)
#### 이름있는 뮤텍스 기반의 프로세스 동기화
- 서로 다른 영역에 있는 프로세스 (A,B) 각각에  포함된 쓰레드 ta,tb가 동기화가 가능할까? 가능하다

프로세스 a가 뮤텍스 키를 생성하였다면, 해당 키는 a의 핸들테이블에 들어가게 된다.
프로세스 b가 뮤텍스를 사용하고자 한다면, b의 핸들테이블에 해당 핸들이 저장되어야 한다. 그러기 위해서는 프로세스 b가 뮤텍스 키를 찾아봐야 하며 이때 이름을 가지고 뮤텍스를 찾게 되며 그러기 위해서는 `아름있는 뮤텍스`를 사용해야 한다.

**하나의 프로세스 내 쓰레드끼리의 동기화는 핸들을 통해서, 다른 프로세스 쓰레드끼리는 뮤텍스 이름을 통해서**

## 세마포어 vs 뮤텍스 차이
- 키의 갯수
- `소유`
	- 뮤텍스의 경우 A가 키를 얻었을때, A가 키를 Release해주어야 한다.
	-  만약 A가 반환을 하지 않고 사라질 경우, B `WAIT_ABANDONED`가 호출되고 윈도우 시스템이 이에 대하여 b에게 키를 전달해준다. 그러나 세마포어는 소유 개념이 없다. COUNT값으로 키들을 관리하기 때문이다. (윈도우즈의 특성)
