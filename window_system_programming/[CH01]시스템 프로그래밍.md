# 시스템 프로그래밍


## 하드웨어 구성
- CPU
    - ALU
    - Control Unit
    - Bus Interface
    - Register Set

I/O Bus를 통해 입력들어온 요청들은 `Bus Interface`를 통해 레지스터에 전달되며 이후, 컨트롤 유닛이 연산자와 피연산자를 control하여 ALU에 계산을 부탁한다.

c.f) `Clock Pulse`
- 동작 타이밍을 맞춰준다.
- 필요성: 요소들의 동기화
요소들의 동기화를 위하여 clock신호가  필요로 한다.


## 프로그램 실행과정

`전처리기 -> 컴파일러 -> 어셈블러 -> 링커`


1. 전처리기
    - #으로 시작하는 지시자 -> 프로그래밍 언어

2. 컴파일러
    - cpu의 명령어로 번역(Control Unit이 해석함)
3. 어셈블러
    - 바이너리 코드로 번역한다.
    - CPU 보드 개발당시, 약속했던 (Control Unit 명령어 : 2진수)
4. 링커
    - 라이브러리와의 결합
    - 제일 이해가 안간다.
    - 실행파일 = 바이너리 + 외부 라이브러리

## Stored Program Concept
> 폰노이만 아키텍처
"명령어는 메모리에 저장되어 Fetch, Decode, Execution 되어야 한다."
- Fetch
    - I/O BUS
    - cpu 내부로 명령어 이동
- Decode
    - 명령어 해석
    - 컨트롤 유닛에 의해 control
- Execution  
    - ALU에 의해 연산
    - ALU가 중심이 되어 요소요소들이 협력하여 연산된다.



`code editor -> 전처리기 -> 컴파일러 -> 어셈블러 -> 링커 -> 실행파일 -> load ->Fetch -> Decode -> Execution`

메모리에 load된 명령어들은 I/O BUS에 Fetch되고 Bus Interface에 맞추어 Register에 Fetch된다. 이후 Control Unit에 의해 Decode되며 이는 ALU에 의해  Execution된다.


## I/O BUS ( 3 )

- Data Bus
- Address Bus
- Control BUS (일의 순서)


## 실행파일 생성과정 (자세히)
> exe 실행파일이 생성되기 까지의 과정을 기술한다.

- 의문점1: 전처리기와 링키의 차이점이 무엇일까
- 의문점2: 정적링킹과 동적 링킹의 차이점

- 실행파일 생성과정
    1. preprocess
        - 역활
            - `#include` 헤더파일
            - `#DEFINE`,`#ifdef`: 매크로 치환
        - `.i`파일을 생성한다.
        - 전철리가 끝난 파일 엯시 소스파일과 마찬가지로 텍스트 파일이다.
    2. compile
        - 3단계
            1. Front_end
                - 언어 종속적인 부분을 처리함
                    - 이 단계에서 c언어와 c++, JAVA등 다른 언어로 작성된 코드들이 각각 다른 모듈에 의해 처리됨
                - (1) 어휘 분석: Token 단위로 나눈다.
                - (2) 구문 분석: 토큰으로 Parse Tree 생성
                    - 문법적 오류 검출
                - (3) 의미 분석:
                    - 의미상 오류 검출( 함수의 매개변수 실수, 변수의 자료형 불일치 등)
                - (4) 중간 표현 생성:
                    - 언어 독립적인 특성을 제공하기 위해트리 형태의 중간표현(GIMPLE Tree)를 생성함     
            2. Middle_end
                - GIMPLE 트리를 SSA(Static Singgle Assignment)형태로 변환한 후 아키텍쳐 비종속적인 최적화를 수행 ㅎ후 RTL(Register Treansfer Language, 고급 언어와 어셈블리 언어의 중간 형태)을 생성함.
                - c.f) 아키텍쳐 비종속적인 최적화: 서로 다른 CPU 아키텍쳐에 구애받지 않고 공통적으로 수행할 수 있는 최적화
                - 프로그램은 한번 컴파일 되면 다시 컴파일 하기 전까지 변경이  불가능(리버싱 예외) 하므로 최적화가 중요하다.
            3. Back_end
                - 전달받은 RTL을 Optimize
                    - 아키텍처 비종속적 최적화
                    - 아키텍쳐 종속적 최적화
                - 어셈블리어로 구성된 .s 파일이 만들어진다.
    3. assemble
        - 컴파일이 끝난 어셈블리 코드는 어셈블러에 의해 기계얼로 어셈블된다.
        - 최종적으로 목적코드(.o)를 생성한다.
            - ELF 바이너리 포맷구조 (각 바이너리의 정보를 효과적으로 파악하기 위해 명령어와 데이터 범위 등을 일정한 규칙을 가지고 형식화 해놓은 구조)
                - 어셈블된 프로그램의 명령어(Instruction)
                - 데이터
            - 다음 단계에서 링커가 여러 바이너리 파일을 하나의 실행 파일로 묶기 위해 각 바이너리의 정보를 효과적으로 파악하기 위해 일정한 규칙을 가지도록 형식화
    4. linking
        - 링커는 오브젝트 파일들과 프로그램에서 사용된 표준 c 라이브러리, 사용자 라이브러리들을 링크한다. 