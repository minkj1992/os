# [CH04] 컴퓨터  구조에 대한 두번째 이야기

## 컴퓨터 구조의 접근방법(1)
- 프로그래머 관점
    - 컴퓨터 디자인은 1)레지스터 2) 명령어 디자인
- 레지스터 디자인의 핵심
    - 레지스터는 몇 비트?
        - 하나의 명령어 단위와 같은 크기의 레지스터 사이즈를 구성해야 한다.
        - 그렇지 안다면 단일 명령어를 복수의 레지스터에 쪼개어 저장해야한다.
    - 몇개의 레지스터로 구성?
        - 많을수록 좋지만, 한계가 있어 8개 정도가 대표적
    - 레지스터 각각을 무슨 용도로 사용할 것인가?를 기준으로 레지스터를 구분지어주면 장점은
        - 명령어 단순화
        - 각 레지스터 처리 속도 승가
    - `ARM(8)`
        - r0: 범용 레지스터(연산)
        - r1: 범용 레지스터(연산)  
        - r2: 범용 레지스터(연산)
        - r3: 범용 레지스터(연산)
        - r4: ir(Instruction Register)
        - r5: sp(Stack poiinter)
        - r6:lr(Link Register)
        - r7: pc(Program Counter)
        - 
## 컴퓨터 구조의 접근방법(2)
- 명령어 구조 및 명령어 디자인 해보기
    - 명령어의 기본 모델(앞으로의 설명을 16비트라고 가정)
    - 사칙연산 명령어 구성
        - 예약 + 연산자(3bit) + 저장소(레지스터, 3bit) + 피연산자1 + 피연산자2
        - 피연산자 1,2: 레지스터 / 숫자
        - cpu들이 연산결과를 일단 레지스터에 저장한다.
    - 프로그래머가 명령어를 디자인하고, 이를 해석할 수 있는 ALU를 함께 디자인한다.
    - RISK(Reduced) (<-> `CISK`(Complex) cpu)
        - 명령어가 단순화되어 만들어낸 cpu로, 개발자가 코드 짜기는 힘들지만 속도적인 우위가 있다
        - `Fetch`, `Decode`, `Execution`을 하는 cpu개발할 때 , RISK는
        ```
            [F][D,F][E,D,F],[F,D,E].....
            각자 F,D,E영역이 독립적이니 사용ㅎ하지 안는 명령어를 실행할 수 있다. 일반적으로 5개의 명령어에 대해서는 7개의 CLOCK으로 커버 가능(`O(N+2))`
        ```

## LOAD & STORE 명령어 디자인
- 명령어의 제한
    - 사칙연산의 피 연산자는 숫자 / 레지스터
    - 연산결과는 레지스터에 저장
    - 즉 레지스터를 통해 모든 연산을 진행 하겠다.
- LOAD 명령어
    - DESTINATION: 데이터를 저장할 레지스터 정보
    - SOURCE: 데이터를 읽어올 메모리의 주소정보
    - `LOAD r1 0x20` : r1에 0x20데이터를 넣어주어라

- STORE 명령어
    - `STORE r1 0x20`

```c
int a = 10;
int b = 20;
int c = 30;
c = a+b;
```

```
LOAD R1 OX10
LOAD R2 OX20
ADD R3 R1,R2
STORE R3 0X30
```

## Direct Addressing (메모리 참조 )모드와 Indirect 모드
Addressing이란 특정 메모리를 참조하는 것을 의미한다.
방식은 2가지이고 필요한 이유는 **명령어 디자인 시 필요로 하는 바이트수를 제한했기 때문**이다.

- Immediate Addressing
    - `ADD 5`
    - 명령어 바이트가 제한적이여서 수를 나타내는데 크기 제한이 있다.
- Direct Addressing
    - `ADD A`이후 `A`에서 Operand 5를 읽어들임
    - Immediate과 마찬가지 문제점
- Indirect Addressing
    - Instruction의 줏소 필드는 실제 Operand의 주소 값을 가지고 있는 주소를 가진다.
    - ADD A -> A B -> B 5 -> ADD 5
    - n가지 연산을 위해서는 O(2^n)개의 주소 공간이 필요하다.


