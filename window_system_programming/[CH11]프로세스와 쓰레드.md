# [CH11] 프로세스와 쓰레드

## 쓰레드
- 프로세스란
    - 쓰레드가 실행될 수 있는 환경을 제공해준다. (CODE, DATA, HEAP)
- 쓰레드란
    - 프로세스에서 실행의 흐름
    - 프로세스 Code영역에 각 thread_main() 코드 + 독립적인 Stack + 공통영역 (Data, Heap, Code)으로 구성된다.

- 프로세스 구조
    - CODE
    - DATA (전역 변수)
    - HEAP (동적 할당)
    - STACK(지역 변수)
- 쓰레드
    - STACK영역만 별도로 분리해준다면 프롯세스를 하나 더 생성하지 않고도 여러 흐름을 생성해 줄 수 있겠다.
    - CODE, DATA, HEAP 영역은 프로세스와 공유한다.
    - Q) 쓰레드는 scheduling 해주는가?
    

## 프로세스 구조
- CODE 영역
    - 함수
        - 전역함수
        - main()
            - 쓰레드가 생성될때마다 m2(), m3()...추가

## Windows에서의 프로세스와 쓰레드

**윈도우의 스케줄러는 스레드를 스케줄링해준다.** 이때 상태정보를 윈도우에서는 프로세스가 아닌 쓰레드가 지닌다.( 여기서 상태정보란 Running, Blocked, Ready, Stop, Start이다. Blocked는 I/O일때와 우선순위가 낮을 경우. ) 윈도우에서 실행의 주체는 프로세스가 절대로 아니다. 일반적으로 프로그램을 생성해 돌릴때 만들어지는 main()함수도 메인_쓰레드가 생성되어 main()함수를 호출해줌으로써 실행이된다. 

## 쓰레드 구현 모델
 
- **커널 레벨 쓰레드 VS 유저 레벨 쓰레드**
    - 쓰레드를 제공하는 OS와 그렇지 않은 OS가 있다. 쓰레드를 제공하지 않는 OS에서는 유저가 외부 LIBRARY를 가져와서 쓰레드를 생성 (유저 레벨 쓰레드)하고, 커널이 쓰레드를 API로 제공한다면 커널 레벨 쓰레드이다.
    - 커널 레벨 쓰레드에서는 커널이 쓰레드를 관리 할 수 있어서, 쓰레드 정보들을 커널상에서 모니터링해주고 스케쥴러가 스케쥴링해준다.
    - 유저레벨 쓰레드에서는 유저영역에 쓰레드 외부 라이브러리가 포함되어 있기 때문에, 커널 영역에서 커널은 현재 실행됙고있는 것이 쓰레드인지를 구별할 수 있는 방법이 없다. 즉 유저 레벨 쓰레드에서는 커널영역에서 프로세스 정보들만 존재하고 스케줄링과 우선순위들을 프로세스 단위로 처리한다. 
    - 스케줄링 시간에 대한 차이
        - 상황: 1에 대한 CPU WORKING TIME에 대해서 2개의 프로세스를 실행하고 각 프로세스의 우선순위는 동일하다. 프로세스1에는 2개의 쓰레드, 프로세스2에는 1개의 쓰레드가 존재한다.
        - 커널레벨 쓰레드: 커널이 쓰레드 정보가 있어 쓰레드에게 우선순위를 할당 가능하다.
            - 프1_쓰1: (1/3)
            - 프1_쓰2: (1/3)
            - 프2_쓰1: (1/3)
        - 유저레벨 쓰레드: 커널이 쓰레드 정보가 없어 프로세스에게 우선순위를 할당한다.
            - 프로세스1(1/2)
                - 프1_쓰1(1/4)
                - 프1_쓰2(1/4)
            - 프로세스2(1/2)
                - 프2_쓰1(1/2)

    - 스케줄링 CONTEXT SWITCHINGG에 대한 차이
        - (위와 같은 상황에서)프1_쓰1이 BLOCKED 되었다.
        - 커널 레벨 쓰레드
            - 쓰레드 단위로 문맥전환이 일어난다.
            - 그러므로 위의 상황에서는 프1_쓰2를 실행시킨다.
        - 유저 레벨 쓰레드 (단점)
            - 커널이 쓰레드에 대한 정보를 알 수 없기 때문에, 만약 프1_쓰1이 잠시  BLOCKED 되었다면 이로 인하여 프로세스1이 BLOCKED 되었다고 해석하고 프2_쓰1으로 문맥전환이 일어난다.
            - 즉 **프로세스 단위로 문맥 전환이 일어난다.** -> 이로 인하여 STARVATION 현상이 일어날 수도 있다. (프1_쓰2가 정말로 실행을 해야 하는 상황임에도 불구하고, 프로세스2로 문맥전환이 일어나기 때문)

## 커널 모드와 유저 모드
> 유저 모드 쓰레드는 빠르고  커널 모드 쓰레드는 상대적으로 느리다. 왜 이런 현상이 일어나는지 알아보겠다.
- 프로그램이란 크게는 `os` + `application`이라 할 수 있다.
- 이때 os 영역을 커널 영역, app 영역을 유저 영역이라 칭하고, 운영체제 모드는 커널 모드/ 유저 모드 총 2가직가 할당된다.
- 커널 모드에서는 운영체제 관련된 다양한 기능들을 사용할 수 있고, 유저 모드에서는 커널 기능을 사용할 수 없다.
- 즉 application을 돌리는 상황에서는 유저모드로 사용을 하다, os 리소스와 스케쥴링과 같은 커널 레벨 기능이 필요하면 mode 변경을 해주고 그 기능을 실행해준뒤 다시 모드가  변경된다. 여기에 따른 overhead가 존재한다.

## 장단점
- 커널 레벨 쓰레드
    - 장점: 커널에서 직접 제공해 주기 때문에 안전 + 다양한 기능성 제공
    - 단점: 유저 모드에서  커널 모드로의 전환이 빈번(스케쥴링을 쓰레드 단위로 하기 때문에, 커널에서 쓰레드를 관리해주기 때문에)ㄴ
- 유저 레벨 쓰레드
    - 장점: 속도가 빠르다. (유저 모드에서  커널 모드로의 전환이 필요없다 + 프로세스 단위로 스케줄링이 일어나서 문맥전환이 비교적 적다)
    - 단점: 프로세스 단위 블로킹(자식 쓰레드중 하나라도 블로킹이 되면 프로세스가 블로킹 된다.)