# [CH13-14] 쓰레드 동기화  
> 쓰레드 동기화 기법

#### 동기화
> 동기화는 `접근 동기화`와 `실행순서 동기화`로 존재한다.
`접근 동기화`란 무엇일까? A,B 쓰레드가 특정 코드 블럭(Critical section)에서 Race Condition이 일어날 경우 해결 할 수 있는 방법은 해당 영역에 `접근을 동기화` 해주는 것이다. 접근 동기화란 메모리에 접근(R/W) 순간에 하나의 쓰레드만 접근하도록 하겠다는 뜻이다.

실행순서 동기화란? `3+3*4 = 15`에서 +보다 *이 먼저 실행되어야 하지만 멀티 쓰레딩에서 2개의 연산자가 같은 우선순위를 가진다면 +가 먼저 실행 될 수 있다. 이를 방지하기 위해 실행순서를 컨트롤 해주는 것이, `순서 동기화`라고 한다.


#### 동기화가 필요한 이유
서로 다른 일을 하던 쓰레드들이더라도 언젠가 서로 마주치게 될 수 있다. 대표적으로 각 쓰레들의 자원 사용에 대한 동시적 요구가 있다. 동시적으로 자원을 수정하게 되면 race condition이 일어나고, 이를 막아주기 위해서 `임계영역 접근 제어(접근동기화)`를 실행해주지만, 무작위로 임계영역을 사용하도록 쓰레드들을 스케쥴하면 1) 올바른 연산을 못할수도 (앞서 +,*) 2) 10초면 끝나는 쓰레드와 1시간반 일해야 하는 쓰레드중 후자가 먼저 임계영역을 차지해서 Starvation이 일어나게 만들 수도 있다. 이러한 현상을 막하내기 위하여 `순서 동기화`기법을 사용한다. 순서 동기화는 스케줄러와 같은 의미이다.

| 동기화 기법 | 동기화 실행 주체 |
|---|---|
|크리티컬 섹션 | 유저 모드 동기화 |
|인터락 함수 | 유저 모드 동기화 |
|뮤텍스 | 커널 모드 동기화 |
|세마포어 | 커널 모드 동기화 |
|이름있는 뮤텍스 | 커널 모드 동기화 |
|이벤트 기반| 커널 모드 동기화 |

- `이벤트 기반 동기화`만 `실행 순서에 대한 동기화`를 뜻하고, 나머지는 임계영역 접근에 대한 `접근 동기화`를 뜻한다.
- `커널 모드`는 커널 단계에서 메모리 위치 접근에 `락`을 걸어주는 방식
- `유저 모드`는 소프트웨어적으로 접근을 막는 것을 뜻함

# `접근 동기화`
## 1. `유저모드 동기화`

## 1-1. `크리티컬 섹션`

```c
CRITICAL_SECTION gCriticalSection; // 크리티컬 섹션 오브젝트 생성
InitializeCriticalSection(&gCriticalSection); // 오브젝트 초기화
...중략...
EnterCriticalSection(&gCiticalSection);	// 임계영역 집입을 위한 크리티컬 섹션 오브젝트 획득
...
gTotalCount++; // 임계영역
...

LeaveCriticalSection(&gCriticalSection); // 크리티컬 섹션 오브젝트 반환

... 중략 ...
DeleteCriticalSection(&gCriticalSection);	// 크리티컬 섹션 free
```

- 순서
	1. 키 생성
	2. 키 초기화
	3. 키 획득요청 -> 키 획득
	4. 임계영역 진입
	5. 퇴장 및 키 반납
	6. 키 제거
- **세마 포어와의 차이점이 뭘까?**

## 1-2. `인터락 함수 기반 동기화`
사실 임계영역은 변수 한 두개일 경우가 많은데, 이런 단순한 경우를 해결해 주기 위해서 `인터락 함수`가 등장하였다.

예제로 아래의 임계영역 동기화 코드는 
```c
EnterCriticalSection(&gCiticalSection);	// 임계영역 집입을 위한 크리티컬 섹션 오브젝트 획득
...
gTotalCount++; // 임계영역
...
LeaveCriticalSection(&gCriticalSection); // 크리티컬 섹션 오브젝트 반환
```
인터락 함수를 사용하면
```c
InterlockedIncrement(&gTotalCount);
```
로 줄일 수 있다.

인터락 함수는 `원자적 접근`(Atomic Access)를 보장한다. 즉 **한 순간에 하나에 의해서만 연산된다.**

## 2. `커널 모드 동기화`
> 커널 레벨에서 서로 다른 두 쓰레드의 상태를 변경시키는 방법
- 무식하게 스케줄러가 처리해주는 방법
- 뮤텍스 / 세마포어
- 이름있는 뮤텍스
- 이벤트 기반

## 2-1. `인터럽트 DISABLE`
> 무식하게 스케줄러의 타이머 인터럽트를 DISABLE로 꺼준다.
스케줄러는 일정 시간이 흐르면 `Context Switching`이 일어난다. 그렇다면 스케줄러가 일정 시간을 어떤식으로 감지할까? 내부적으로 살펴보면 CPU는 `클럭`을 기준으로 일을 한다. 이 클럭이 몇번 돌았는지를 기준으로 CPU는 OS에게 시간 신호를 쏴주는데, 이를 `Timer Interrupt`라고 한다. (HW가 ㅣ간과 상관없이 특정 event에 대해서 os에게 신호를 주는 `I/O 인터럽트` 등 다양한 interrupt 가 존재)  스케줄러는 이렇듯 timer와 다른 우선순위 Interrupt에 기반하여 Context Switching을 일으켜 주고, 스케줄링 알고리즘에 의해서 올바르게 task들을 스케줄링한다.

이때 A쓰레드가 임계영역에 들어간 순간 `타이머 인터럽트`를 꺼주게 되면, 스케쥴러는 A작업이 끝날때 발생하는 interrupt나 다른 외부 I/O Interrupt를 제외하고는 A의 작업을 Context Switching 시켜줄 방법이 없게되므로 A는 선점적으로 Critical Section을 사용할 수 있다.

- 사용방법
	1. Time Interrupt DISABLE
	2. A Thread 크리티컬 섹션 진입
	3. 작업 종료후 Timer Interrupt ENABLE



## 2-2. 세마포어와 뮤텍스
> 세마포어, 뮤텍스(바이너리 세마포어) 둘 모두 키를 사용하여 임계영역 접근을 통제한다.

### 뮤텍스
- 뮤텍스
	- create Mutex
	```c
		HANDLE CreateMutex(
			LPSECURITY_ATTRIBUTES lpMutexAttributes,	//보안설정
			BOOL bInitialOwner,	//소유자 지정(TRUE, FALSE), 이 함수를 실행한 스레드만 뮤텍스 키를 소유할 것인지
			LPCTSTR lpName	//뮤텍스 이름 지정	
		);
	```
	- 위의 함수는 뮤텍스의 키를 생성시킬 수 있다.
	- 이는 커널 레벨에서 실행되는 함수로 이를 실행하면 뮤텍스에 대한 `커널 오브젝트`가 생성된다.
	- 그리고 그에 대한 `핸들`이 반환된다.
- 뮤텍스 동기화 과정
	1. `CreateMutext()`를 사용하여 `뮤텍스 커널 오브젝트`를 생성
	2. `WaitForSingleObject()`를 사용하여 뮤텍스 대기 후 획득
		- 커널 오브젝트가 `Signaled` 되기를 기다린 후, 획득하게 되면 `NonSignaled`로 변경
	3. 임계영역 작업 종료 이후 `ReleaseMutex()`  뮤텍스 반납
		- `뮤텍스 커널 오브젝트`를 `Signaled`로 상태 변경 
- `CriticalSection`기법과의 차이점
	- 가장 중요한 차이는 **커널 레벨에서 뮤텍스는 처리하고 CriticalSection은 유저영역에서 처리한다.**

### 세마포어
기본적으로 `뮤텍스`와 동일하지만, 세마포어는 키가 여러개 존재하기 때문에, Count 변수를 통해서 n개의 세마포어를 관리해주고 이 값이 0이 되는 순간, `Non-Signaled`로 변경시켜 Blocking 시킨다.

한가지 궁금하였던 것은 리소스가 1개인 상황에서 세마포어 키를 10개 만들어서 사용하면 어떻게 Race Condition이 일어나지 않는지 궁금했었는데, 세마포어는 리소스 갯수가 키의 갯수랑 같게 하는게 정석인 것 같다. 예를들면 프린터의 갯수가 5개 있다면 세마포어를 5개 키 만들도록 설정하는 것

## 2-3. `이름있는 뮤텍스 기반의 프로세스 동기화`
> 지금까지는 한 프로세스 내의 쓰레드들의 동기화를 알아보았다. 만약 서로 다른 프로세스 내 쓰레드들 간에 동기화를 하려면 어떻게 해야 할까?

프로세스 A,B,C가 존재하고 이에대해 각 프로세스당 a,b,c쓰레드가 존재한다. 이때 이 쓰레드들 끼리 동기화가 가능할까? 가능하다. 어떻게 가능할까?

위의 상황에서 A프로세스가 `뮤텍스`를 생성한다. 프로세스 A에서 생성된 뮤텍스는 당연히 프로세스 내에있는 a 쓰레드가 접근 가능하다. 여기서 프로세스 B 프로세스의 쓰레드 b도 뮤텍스에 접근을 하고 싶다면 조치를 취해주어야 한다. 

B에게 뮤텍스 핸들값(커널오브젝트 id)을 전달해준다? 프로세스마다(윈도우에서는 쓰레드마다) 핸들 테이블은 1개씩 존재한다. 즉 핸들 주소는 해당 프로세스 내에서만 의미가 있다. 

나의 프로세스 내에 존재하는 쓰레드들 간의 동기화를 할 때엔 핸들을 이용했다. 하지만 현재 상황은 뮤텍스의 핸들을 직접 얻을 수 없다. 그리하여 커널에서 여러 프로세스들 끼리 공유할 수 있는 변수를 하나 생성해 주었고, 이를 **뮤텍스 이름**이라고 한다. **프로세스안에 쓰레드들 간에 동기화를 진행해주고자 한다면 뮤텍스/세마포어 이름을 통해서 동기화 시켜줄 수 있다.**

### c.f 세마포어 vs 뮤텍스 (소유의 개념)
뮤텍스는 키가 1개만 존재하기 때문에 현재 키를 사용하고 있는 쓰레드에 `키`가 소유된다. 윈도우즈에서는 특정 리소스가 특정 쓰레드에 소유될때 `반환이 적절히 이뤄지지 않는다면` 자동으로  리소스를 회수해 `WaitForSingleObject()`하고 있는 쓰레드에게 전달해준다. 다만 세마포어는 이런 소유의 개념이 없다. 

그렇다면 세마포어 키를 가지고 있던 쓰레드가 임계영역 안에서 소멸해 버리면 해당 리소스는 Memory leak처리가 되는 건가?

# 실행순서 동기화

> 외부 -> 입력 -> OS -> 출력 -> 파일

## c.f) 생산자/ 소비자 모델
> 보는 관점에 따라 I/O모델, 쓰레드 모델
- 배경
	- 외부에서는 얼마만큼의 입력이 들어올지 모르기 때문에 입력부분은 엄청 큰 메모리를 두고 있었어야 했지만 이는 비효율적이었다. 또한 입력에서 출력을 넘겨주는 부분에서도 중간에 동기화를 위하여 기록해주는 Buffer의 필요성이 존재하였다.
- 특징
	-  외부에서 입력이 들어오면 OS를 거쳐 버퍼에 데이터를 넣어준다. 생산자가 생산을 완료하면 신호를 보내주고 소비자가 소비를 시작한다(파일입력, 모니터 출력)

## 이벤트 기반 동기화

### 1, 이벤트 기반 동기화
쓰레드에 어떤 이벤트가 발생했는지에 따라서 다른 쓰레드가 동작을 결정할 수 있다. 위의 생산자/소비자 패턴에서 생산자가 버퍼에 모두 옮겼을 때 이제 가져가도 된다는 것을 소비자가 알아야 한다. 이를 위해서는 생산자 측에서 공유할 커널 오브젝트(버퍼?)를 하나 만들고, 소비자는 이에 대한 핸들을 얻어서 그것을 확인한다.

작업이 완료되면 생산자는 `SetEvent`로 `NonSignaled` ->`Signaled`상태를 변경시켜주고 소비자가 실행하면서 다시 `Signaled` -> `NonSignaled`로 변경시킵니다. 작업이 끝나면 소비자는 `NonSignaled` ->`Signaled` 시켜준다. 

- `CreateEvent`
- 위의 메서드를 사용하여 Event를 생성한다면 `수동 리셋 모드 이벤트`, `자동 리셋 모드 이벤트`를 결정할 수 있다.
	- 수동 리셋 모드 이벤트
		- 생산자, 소비자 모두 SetEvent를 통해서 Signaled/Non-Signald를 실행해준다.
		- 생산자 과정과 소비자 과정으로의 전환을 수동적으로 선택할 수 있다.
	- 자동 리셋 모드 이벤트
		- 생산자 측에서 SetEvent는 수동
		- 소비자 측에서 버퍼를 사용(소비자 쓰레드 실행) + nonSignaled로 공용 커널 오브젝트(버퍼) 상태 변환 시켜주는 것이 자동
		- **자동으로 소비자가 실행되니, 하나의 생산자에 하나의 소비자 1:1관계가 강제된다.**


### 2. 타이머 기반 동기화
> 정해진 시간이 지나면 Timer Interrupt가 발생하여 Signaled 상태가 된다.

타이머를 기반으로 쓰레드를 동기화 하는 것은, 임께 영역 문제 해결과는 관점이 다르다. 타이머 기반 동기화는 **쓰레드의 실행시간 및 실행주기를 결정**하겠다는 의미입니다. 

- 타이머
	1. 수동 리셋 타이머
		- 가장 일반적인 타이머로 **알람시계**
	2. 주기적 타이머
		- **알람시계 + 주기**
타이머도 커널 오브젝트로 타이머가 울린다는 것은 바로 이 커널 오브젝트가 signald 상태가 되었다는 말과 같다. 타이머 커널 오브젝트를 생성하면 나오는 `타이머 핸들`은 타이머가 어떻게 동작할지를 결정해준다.
