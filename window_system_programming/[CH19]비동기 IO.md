
# [CH19]비동기 I/O

## I/O와 CPU CLOCK의 관계
- CPU 클럭이 높아질수록 연산 속도가 높아진다.
- I/O역시 CPU 클럭에 이러한 연관성을 가지긴 하지만, CPU 클럭보다는 BUS 클럭에 더욱 높은 연관성을 가진다.
	- 데이터 전송은 버퍼 단위로 이동
	- 예를 들어 설명해보자면, A라는 시스템에서 B라는 시스템으로 데이터를 전송할 때, A 시스템과 B시스템의 클럭이 서로 다르다면, 만일 빠른 클럭의 시스템에 맞춰서 ㅂ퍼를 전송시, 느린 시스템은 이 데이터를 받지 못한다. 
	- CPU 클럭은 BUS클럭에 비해 훨씬 빠르다.
	- 그러므로 I/O연산시 BUS 클럭에 시스템은 비례해서 작동하게 된다.

- I/O 작업
	- 로컬 데이터 전송
		- Cache
		- HDD
		- RAM
		- 이처럼 메모리 계층구조 간의 데이터 전송
		- 데이터 전송 서비스는 연산 속도보다 더욱 느리다.
	- 네트워크 데이터 전송
		- 네트워크 i/o는 로컬 데이터 i/o작업에 비해서 더욱 느리다.
## 비동기 I/O의 종류
기본적으로 i/o작업은 `wait`시간이 길고, cpu 사용률은 상당히 떨어진다.
1. `Overlapped I/O`
	- `read`와 같은 작업들은 wait타임이 길다. 발상을 전환해서 어차피 wait할거 필요한 i/o작업들을 모아서 요청하고 한번 기다릴 시간으로 n개의 i/o 연결을 이끌어낸다. (어차피 cpu 소모는 그리 크지 않아서 부담없이 overlap 시켜서 작업을 요청할 수있다.) 
	- 정리하자면 i/o연산을 몰아서 수행하되, 각 연산에서 요청을 보내는 즉시 cpu에 대한 사용을 반환하고 다음 i/o 연산을 처음과 같은 처리를 해주어 반복한다.
	- 느린 속도 한계를 병렬적으로 실행시키므로 cpu 사용효율과 i/o wait을 줄일 수 있다.
2. `Completion Routine I/O`
	-  중첩 I/O가 끝났을 시, 각 작업별 부가적 작업을 수행해 주어야 할 경우가 존재한다. 그러나 병렬적으로 실행시 어느 작업이 먼저 끝날지 알 수 없기때문에 프로그래머 코드에서 각 I/O작업을 일일이 확인해주고, 그것이 끝나는 순간 다음 작업을 정해주어야 하는데 그러한 검사기능 대신 `TASK 자체에 complete되었을 경우 다음 Routine으로 진행되도록 심어주는 기능`이 `completion Routine`이다.