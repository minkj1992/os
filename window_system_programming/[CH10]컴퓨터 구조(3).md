# [CH10]  컴퓨터 구조에 대한 이야기 (3)

## 절차적 함수 호출(Procedure Call)
- cpu가 어떻게 함수를 호출할까?
- 함수
    1. 지역 변수처리
    2. 인자 전달
    3. 실행의 이동(A함수 -> B함수)

## 스택 프레임
> 지역 변수 처리편

- 스택 프레임((Stack Frame)이란
    - 임의의 함수 내에서 선언된 메모리 공간
    - **함수 호출 과정에서 할당되는 메모리 블록(지역변수의 선언으로 인해 할당되는 메모리 블록)**
    - 다음 위치 지정 어떻게 이동? 
        - 눈여겨 볼점 (흐름제어, 충돌제어)
            - 함수 메모리 블록들 끼리 충돌이 일어나지 않고
            - 차곡차곡 순서대로 쌓여진다 
    - 레지스터가 함수가 들어올때 메모리 공간 어디까지 쌓였는지 기억하고, 다음 프레임이 들어올 때 해당 위치 공간에 쌓아준다. (sp 레지스터, stack Pointer)
    - 반환(되돌아갈 위치 기억)
        - fp(frame Pointer)레지스터를 통해 함수가 종료되고 반환되어야할 위치를 기억해주어 흐름을 제어해준다. 함수 호출되기 이전의 공간으로 Fp에 저장을 해두어야 한다.

- sp 레지스터
    -  역할: 현재까지 사용된 스택의 위치를 저장하기 위한 레지스터
    -  함수에서 변수가 하나 하나씩 할당될 때마다 sp++ 하여 다음 변수가 할당될 메모리 위치를 가리킨다.
    -  호출한 함수가 종료될 때, 함수 안에 선언된 변수 모두 반환되어야 하므로, 스택 프레임 단위로 sp레지스터 값을 이동(fp에 들어있는 이전 스택 프레임 주소)해야 한다.
    -  sp 레지스터 값을 아래로 이동시키면 이전에 선언한 변수를 반환할 수 있음. 
    - **궁금한점은 함수 반환 시 sp에 바로 fp값을 넣는게 아닌 while(sp>fp){sp--;} 구조를 취하면 되는게 아닌가?**
- fp 레지스터
    - 되돌아갈(함수 호출 이전의) sp위치 저장
    - 현재 코드에서  함수가 호출된다면, sp값을 fp에 저장함. 이때 fp값이 들어있다면, 그 값을 스택에 저장시킨다.
    - 즉 sp(현재위치), fp(이전 함수call위치), stack[sp(현재위치)] = fp
    - ```c
        // 함수를 실행시키는 과정
        while(return){
            if (함수 호출){
                stack[sp] = fp;    //이전 fp값을 stack에 기록
                fp = sp;    //fp update
            }
            sp++;
        }
    ```
    - ```c
        // 함수 return 과정
        while(return){
            변수.free();
            sp--;
            if (sp == fp){
                fp = stack[sp];    //이전 fp값을 stack에 기록
            }
        }
    ```
- FP 레지스터는 SP 레지스터의 백업본이다. 
- 함수 return 이란
    - sp의 위치를 fp가리키는 위치로 덮어씌워주는 것이다.

- fp 레지스터의 문제점
    - 함수 호출이 연속적으로 많이 일어나 fp레지스터에 새로운 sp 레지스터의 위치를 저장하게 된다면 이전 값은 덮어씌워져 잃어버리게 될 것이다.
    - 위의 문제점에 의해서  fp 레지스터도 백업을 두는데, 레지스터가 아닌 메모리를 백업으로 둔다. (여러번 sp 레지스터가 update 될 수있기 때문에)
    - 이때 말하고 있는 메모리는 stack frame의 stack이다.


## PUSH & POP
> 인자 전달편
```
지역변수와 마찬가지로 인자들의 life cycle이 stack안에서 동일하게 관리된다.
이로 인해서 stack안에 들어가는 frame 구조를 세분화 시키게되었다.  
```

- `함수 호출 인자의 전달 방식`
    1. stack[sp] = 인자값
    2. sp++;

- 해당 메모리공간에 인자값 저장하기 (`STORE`)
    - 실행시키고자 하는 명령어 STORE 7 sp (7이라는 인자를 sp위치에 저장시키고 싶다.)
    - `STORE 대상(레지스터), 목적지(메모리 주소)`
            - 다음과 같은 명령어 구조에 맞혀주기 위해서는
            - 7 -> r1 레지스터에 저장
            - sp -> 메모리에 저장한 뒤 주소값 반환
    - 즉 명령어 3개 필요(store 명령어, 레지스터에 저장 명령어, 메모리에 저장 명령어)
    - 문제점 해결1 (`PUSH 명령어`)
    ```C
        ADD r1, 7, 0
        STORE sp, 0X40    // IN-DIRECT모드, 0X40에는 SP가 가진 주소값이 들어있다.
        STORE r1, [0X40]
        ADD sp, sp, 4(스택 포인터 + 4(바이트 크기))        
    ```
    - 문제점 해결2 (`POP 명령어`)
    ```C
        ADD sp, sp, -4 or SUB sp, sp, 4    // 4는 인자의 크기이므로 유동적
    ```


## 호출규약과 실행의 이동
> 함수의 흐름 이동

- 함수호출에 의한 실행의 이동과 pc(Program Counter)
```
SP -> FP -> Stack    // 지역변수 저장 방법
PC(Program Counter) -> LR(link register) -> Stack    // 함수호출 이동 방법

함수 호출이 계속되면 PC는 LR에 백업을 요청한다. LR은 stack에 저장해야 한다. 둘 모두 같은 형식을 지녔다.
```
- 함수 호출 규약(64 bit)
- C스타일로 인자를 받는다 (오른쪽 -> 왼쪽)
- Caller에서  stack cleanup이 일어남
- 레지스터를 모두 사용한다. 
